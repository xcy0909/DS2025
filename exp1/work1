#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <ctime>
#include <cmath>
#include <iomanip>

class Complex {
public:
    double real, imag;

    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}

    double modulus() const {
        return std::sqrt(real * real + imag * imag);
    }

    bool operator==(const Complex& other) const {
        const double eps = 1e-9;
        return std::abs(real - other.real) < eps && std::abs(imag - other.imag) < eps;
    }

    bool operator!=(const Complex& other) const {
        return !(*this == other);
    }

    friend std::ostream& operator<<(std::ostream& os, const Complex& c) {
        os << "(" << c.real << "," << c.imag << ")";
        return os;
    }
};

// 比较函数：先按模，再按实部
bool compareComplex(const Complex& a, const Complex& b) {
    double modA = a.modulus();
    double modB = b.modulus();
    if (std::abs(modA - modB) < 1e-9) {
        return a.real < b.real;
    }
    return modA < modB;
}

// 冒泡排序
void bubbleSort(std::vector<Complex>& vec) {
    size_t n = vec.size();
    for (size_t i = 0; i < n - 1; ++i) {
        bool swapped = false;
        for (size_t j = 0; j < n - i - 1; ++j) {
            if (!compareComplex(vec[j], vec[j + 1])) {
                std::swap(vec[j], vec[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) break;
    }
}

// 归并排序的合并函数
void merge(std::vector<Complex>& vec, size_t left, size_t mid, size_t right) {
    std::vector<Complex> leftArr(vec.begin() + left, vec.begin() + mid + 1);
    std::vector<Complex> rightArr(vec.begin() + mid + 1, vec.begin() + right + 1);

    size_t i = 0, j = 0, k = left;
    while (i < leftArr.size() && j < rightArr.size()) {
        if (compareComplex(leftArr[i], rightArr[j])) {
            vec[k++] = leftArr[i++];
        } else {
            vec[k++] = rightArr[j++];
        }
    }
    while (i < leftArr.size()) vec[k++] = leftArr[i++];
    while (j < rightArr.size()) vec[k++] = rightArr[j++];
}

// 归并排序递归函数
void mergeSortHelper(std::vector<Complex>& vec, size_t left, size_t right) {
    if (left < right) {
        size_t mid = left + (right - left) / 2;
        mergeSortHelper(vec, left, mid);
        mergeSortHelper(vec, mid + 1, right);
        merge(vec, left, mid, right);
    }
}

void mergeSort(std::vector<Complex>& vec) {
    if (!vec.empty())
        mergeSortHelper(vec, 0, vec.size() - 1);
}

// 随机生成复数向量（允许重复）
std::vector<Complex> generateRandomComplexVector(size_t n, unsigned seed = 0) {
    std::mt19937 gen(seed == 0 ? unsigned(std::time(nullptr)) : seed);
    std::uniform_real_distribution<double> dis(-10.0, 10.0);
    std::vector<Complex> vec;
    for (size_t i = 0; i < n; ++i) {
        vec.emplace_back(dis(gen), dis(gen));
    }
    return vec;
}

// 查找（实部虚部均相同）
bool findComplex(const std::vector<Complex>& vec, const Complex& target) {
    return std::find(vec.begin(), vec.end(), target) != vec.end();
}

// 插入
void insertComplex(std::vector<Complex>& vec, const Complex& c) {
    vec.push_back(c);
}

// 删除第一个匹配项
bool removeComplex(std::vector<Complex>& vec, const Complex& c) {
    auto it = std::find(vec.begin(), vec.end(), c);
    if (it != vec.end()) {
        vec.erase(it);
        return true;
    }
    return false;
}

// 唯一化（去重）——需先排序
std::vector<Complex> uniqueComplex(std::vector<Complex> vec) {
    std::sort(vec.begin(), vec.end(), [](const Complex& a, const Complex& b) {
        if (std::abs(a.real - b.real) < 1e-9)
            return a.imag < b.imag;
        return a.real < b.real;
    });
    auto last = std::unique(vec.begin(), vec.end());
    vec.erase(last, vec.end());
    return vec;
}

// 区间查找：模在 [m1, m2) 的所有元素
std::vector<Complex> rangeFind(const std::vector<Complex>& sortedVec, double m1, double m2) {
    std::vector<Complex> result;
    for (const auto& c : sortedVec) {
        double mod = c.modulus();
        if (mod >= m1 && mod < m2) {
            result.push_back(c);
        }
    }
    return result;
}

// 测试排序效率
void testSortingPerformance(const std::vector<Complex>& baseVec) {
    std::cout << "\n=== 排序性能测试 (n = " << baseVec.size() << ") ===\n";

    // 顺序
    auto sortedVec = baseVec;
    std::sort(sortedVec.begin(), sortedVec.end(), compareComplex);

    // 逆序
    auto reversedVec = sortedVec;
    std::reverse(reversedVec.begin(), reversedVec.end());

    // 乱序
    auto shuffledVec = baseVec;
    std::random_shuffle(shuffledVec.begin(), shuffledVec.end());

    auto testSort = [&](const std::vector<Complex>& input, const std::string& name, void (*sortFunc)(std::vector<Complex>&)) {
        auto vec = input;
        clock_t start = clock();
        sortFunc(vec);
        clock_t end = clock();
        double time = double(end - start) / CLOCKS_PER_SEC * 1000.0; // ms
        std::cout << name << ": " << std::fixed << std::setprecision(2) << time << " ms\n";
    };

    std::cout << "冒泡排序:\n";
    testSort(sortedVec, "  顺序", bubbleSort);
    testSort(reversedVec, "  逆序", bubbleSort);
    testSort(shuffledVec, "  乱序", bubbleSort);

    std::cout << "归并排序:\n";
    testSort(sortedVec, "  顺序", mergeSort);
    testSort(reversedVec, "  逆序", mergeSort);
    testSort(shuffledVec, "  乱序", mergeSort);
}

int main() {
    const size_t N = 1000; // 可调整大小测试性能
    std::vector<Complex> vec = generateRandomComplexVector(N, 12345); // 固定种子便于复现

    std::cout << "原始向量（前10个）:\n";
    for (size_t i = 0; i < std::min(size_t(10), vec.size()); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << "\n\n";

    // (1) 基本操作测试
    // 置乱
    std::random_shuffle(vec.begin(), vec.end());
    std::cout << "置乱后（前10个）:\n";
    for (size_t i = 0; i < std::min(size_t(10), vec.size()); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << "\n";

    // 查找
    Complex target(2.5, -3.1);
    insertComplex(vec, target);
    std::cout << "插入 " << target << " 后查找: " << (findComplex(vec, target) ? "找到" : "未找到") << "\n";

    // 删除
    removeComplex(vec, target);
    std::cout << "删除后查找: " << (findComplex(vec, target) ? "找到" : "未找到") << "\n";

    // 唯一化
    auto uniqueVec = uniqueComplex(vec);
    std::cout << "唯一化后大小: " << uniqueVec.size() << " (原大小: " << vec.size() << ")\n";

    // (2) 排序与性能测试
    testSortingPerformance(vec);

    // (3) 区间查找
    std::vector<Complex> sortedForRange = vec;
    std::sort(sortedForRange.begin(), sortedForRange.end(), compareComplex);
    double m1 = 5.0, m2 = 10.0;
    auto rangeResult = rangeFind(sortedForRange, m1, m2);
    std::cout << "\n区间 [" << m1 << ", " << m2 << ") 内的元素个数: " << rangeResult.size() << "\n";
    std::cout << "前5个: ";
    for (size_t i = 0; i < std::min(size_t(5), rangeResult.size()); ++i) {
        std::cout << rangeResult[i] << " ";
    }
    std::cout << "\n";

    return 0;
}
